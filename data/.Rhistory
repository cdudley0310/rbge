### Function ###
x$na <- rowSums(!is.na(x[tail(seq_along(x), geneCount)])) # sums the NAs in the columns of x containing accession numbers
x
}
naFindtest1 <- function(x, geneCount = NULL){ # a function for determining which genera lack sequence data and contain only 1 or 2 species
# x = dataframe containing accessions for each gene region of interest
# geneCount = the number of gene regions of interest for the study
### Error Codes ###
if(missing(geneCount)) stop('geneCount argument missing with no default value')
### Function ###
x$na <- rowSums(!is.na(x[tail(seq_along(x), geneCount)])) # sums the NAs in the columns of x containing accession numbers
sum.na <- ddply(x, ~Genus, summarise, number_of_seqs = sum(na), n = table(Genus))
na <- sum.na[sum.na$number_of_seqs == 0 & sum.na$n < 3, ]
}
test1 <- naFindtest(test, geneCount = 4)
test2 <- naFindtest1(test, geneCount = 4)
test1
test2
test <- data[1:1000, 1:4]
test1 <- naFindtest(test, geneCount = 4)
test2 <- naFindtest1(test, geneCount = 4)
test1
test2
test <- AddAccessionsToDF('atpB') # adds the accession numbers for the sequences pulled from NCBI to 'data'
test <- AddAccessionsToDF('matK') # adds the accession numbers for the sequences pulled from NCBI to 'data'
test <- AddAccessionsToDF('ndhF') # adds the accession numbers for the sequences pulled from NCBI to 'data'
test <- AddAccessionsToDF('rbcL') # adds the accession numbers for the sequences pulled from NCBI to 'data'
test
test
test <- data[1:1000, 1:4]
test <- AddAccessionsToDF('atpB') # adds the accession numbers for the sequences pulled from NCBI to 'data'
test
test <- AddAccessionsToDF('matK') # adds the accession numbers for the sequences pulled from NCBI to 'data'
test
AddAccessionsToDFtest <- function(x){ # a function for adding accession numbers to our dataframe ('data')
# x = the gene region of interest used to create the single gene tree; parameter should be written inside quotations
tmp <- read.fasta(file.path('..', 'Results', 'alignments', as.character(x), paste(as.character(x), '_alignment.fasta', sep = '')))
y <- data.frame(regmatches(tmp$seq.name, regexpr('[[:alnum:]]{4,}', tmp$seq.name))) # grabs the accession numbers from the sequence labels
y$Combination <- sub('^.*aceae_', '', tmp$seq.name) # removes everything in the sequence name before the genus, leaving only Genus_species
names(y)[1] <- as.character(x)
join(test, y, by = 'Combination') # join functions similar to merge except that it does not reorder the data frames in question, it simply matches y to x based on 'by = ' argument
}
test <- data[1:1000, 1:4]
test <- AddAccessionsToDF('atpB') # adds the accession numbers for the sequences pulled from NCBI to 'data'
test <- AddAccessionsToDF('matK') # adds the accession numbers for the sequences pulled from NCBI to 'data'
test <- AddAccessionsToDF('ndhF') # adds the accession numbers for the sequences pulled from NCBI to 'data'
test <- AddAccessionsToDF('rbcL') # adds the accession numbers for the sequences pulled from NCBI to 'data'
AddAccessionsToDFtest <- function(x){ # a function for adding accession numbers to our dataframe ('data')
# x = the gene region of interest used to create the single gene tree; parameter should be written inside quotations
tmp <- read.fasta(file.path('..', 'Results', 'alignments', as.character(x), paste(as.character(x), '_alignment.fasta', sep = '')))
y <- data.frame(regmatches(tmp$seq.name, regexpr('[[:alnum:]]{4,}', tmp$seq.name))) # grabs the accession numbers from the sequence labels
y$Combination <- sub('^.*aceae_', '', tmp$seq.name) # removes everything in the sequence name before the genus, leaving only Genus_species
names(y)[1] <- as.character(x)
join(test, y, by = 'Combination') # join functions similar to merge except that it does not reorder the data frames in question, it simply matches y to x based on 'by = ' argument
}
test <- AddAccessionsToDFtest('atpB') # adds the accession numbers for the sequences pulled from NCBI to 'data'
test <- AddAccessionsToDFtest('matK') # adds the accession numbers for the sequences pulled from NCBI to 'data'
test <- data[1:1000, 1:4]
test <- AddAccessionsToDFtest('atpB') # adds the accession numbers for the sequences pulled from NCBI to 'data'
test <- AddAccessionsToDFtest('matK') # adds the accession numbers for the sequences pulled from NCBI to 'data'
test <- AddAccessionsToDFtest('ndhF') # adds the accession numbers for the sequences pulled from NCBI to 'data'
test <- AddAccessionsToDFtest('rbcL') # adds the accession numbers for the sequences pulled from NCBI to 'data'
test
naFindtest1 <- function(x, geneCount = NULL){ # a function for determining which genera lack sequence data and contain only 1 or 2 species
# x = dataframe containing accessions for each gene region of interest
# geneCount = the number of gene regions of interest for the study
### Error Codes ###
if(missing(geneCount)) stop('geneCount argument missing with no default value')
### Function ###
x$na <- rowSums(!is.na(x[tail(seq_along(x), geneCount)])) # sums the NAs in the columns of x containing accession numbers
sum.na <- ddply(x, ~Genus, summarise, number_of_seqs = sum(na), n = table(Genus))
na <- sum.na[sum.na$number_of_seqs == 0 & sum.na$n < 3, ]
}
naFindtest <- function(x, geneCount = NULL){ # a function for determining which genera lack sequence data and contain only 1 or 2 species
# x = dataframe containing accessions for each gene region of interest
# geneCount = the number of gene regions of interest for the study
### Error Codes ###
if(missing(geneCount)) stop('geneCount argument missing with no default value')
### Function ###
x$na <- rowSums(!is.na(x[tail(seq_along(x), geneCount)])) # sums the NAs in the columns of x containing accession numbers
x
}
test1 <- naFindtest(test, geneCount = 4)
test2 <- naFindtest1(test, geneCount = 4)
test1
test2
x$na <- rowSums(is.na(x[tail(seq_along(x), geneCount)])) # sums the NAs in the columns of x containing accession numbers
naFind <- function(x, geneCount = NULL){ # a function for determining which genera lack sequence data and contain only 1 or 2 species
# x = dataframe containing accessions for each gene region of interest
# geneCount = the number of gene regions of interest for the study
### Error Codes ###
if(missing(geneCount)) stop('geneCount argument missing with no default value')
### Function ###
x$na <- rowSums(!is.na(x[tail(seq_along(x), geneCount)])) # sums the NAs in the columns of x containing accession numbers
sum.na <- ddply(x, ~Genus, summarise, number_of_seqs = sum(na), n = table(Genus))
na <- sum.na[sum.na$number_of_seqs == 0 & sum.na$n < 3, ]
na$Genus
}
rm(test, test1, test2, AddAccessionsToDFtest, naFindtest, naFindtest1)
AddAccessionsToDF <- function(x, GENE = NULL){ # a function for adding accession numbers to our dataframe ('data')
# x = dataframe containing combination names; accessions will be added to this dataframe
# GENE = the gene region of interest used to create the single gene tree; parameter should be written inside quotations
### Error Codes ###
if(missing(geneCount)) stop('geneCount argument missing with no default value')
### Function ###
tmp <- read.fasta(file.path('..', 'Results', 'alignments', as.character(GENE), paste(as.character(GENE), '_alignment.fasta', sep = '')))
y <- data.frame(regmatches(tmp$seq.name, regexpr('[[:alnum:]]{4,}', tmp$seq.name))) # grabs the accession numbers from the sequence labels
y$Combination <- sub('^.*aceae_', '', tmp$seq.name) # removes everything in the sequence name before the genus, leaving only Genus_species
names(y)[1] <- as.character(GENE)
join(x, y, by = 'Combination') # join functions similar to merge except that it does not reorder the data frames in question, it simply matches y to x based on 'by = ' argument and adds the columns in y to the tail end of x
}
naFind <- function(x, geneCount = NULL){ # a function for determining which genera lack sequence data and contain only 1 or 2 species
# x = dataframe containing accessions for each gene region of interest
# geneCount = the number of gene regions of interest for the study
### Error Codes ###
if(missing(geneCount)) stop('geneCount argument missing with no default value')
### Function ###
x$na <- rowSums(!is.na(x[tail(seq_along(x), geneCount)])) # sums the NAs in the columns of x containing accession numbers
sum.na <- ddply(x, ~Genus, summarise, number_of_seqs = sum(na), n = table(Genus))
na <- sum.na[sum.na$number_of_seqs == 0 & sum.na$n < 3, ]
na$Genus
}
install.packages('rentrez') # used to search the NCBI database for information on taxa (sequences, accessions, taxonomy, etc.)
install.packages('rentrez') # used to search the NCBI database for information on taxa (sequences, accessions, taxonomy, etc.)
library(rentrez)
install.packages('pbapply') # adds a progress bar to the apply family of functions for monitoring slow functions
library(pbapply)
install.packages('XML') # for unpacking XML files downloaded from NCBI
library(XML)
install.packages('plyr') # for use in summarising the number of accessions obtained per genus with the 'ddply' function; also contains the function 'join', which is similar to 'merge' but does not change the order of rows when combining data
library(plyr)
install.packages('phylotools') # for reading fasta files into R
install.packages("XML")
library(phylotools)
install.packages('seqinr') # for writing final sequence data; as it shares the command 'read.fasta' with phylotools, we only library it when it is required and then detach it
data <- read.csv('./RBGE.csv', header = TRUE) # database containing the species of interest
data <- data[1:4] # the database contains more information than we need for building a phylogeny; for the sake of clarity, we are only taking the first four columns which contain the family, genus, species and combination (Genus species)
data$Combination <- gsub(' ', '_', data$Combination) # for ease of comparison purposes, the ' ' in the combination is replaced with an '_'
rm('test')
SeekAndFind <- function(x, GENE = NULL, SLEN = NULL, RET = 1, REPLACEMENT = FALSE, OUTSIDE = FALSE, WRITE = FALSE, ...){ # a function for searching the NCBI database for sequences IDs and downloading sequence data based on the IDs found
# x = vector containing taxa names
# GENE = the gene region of interest; parameter should be written inside quotations
# SLEN = length of desired sequences to be returned; parameter should be written inside quotations
# RET = the sequence ID to be returned from the NCBI database; defaults to the first sequence ID per species per desired gene; increase if replacing anomalous sequences
# REPLACEMENT = whether the search is being used to search for replacement sequences for deleted taxa or not
# OUTSIDE = whether the search is being used to look for species outside of the primary research area
# WRITE = whether to write the sequences to a fasta file or not; see 'WriteFasta' function for details and arguments
# ... = arguments to be passed on to the 'WriteFasta' function
### Error Codes ###
if(missing(GENE)) stop('GENE argument missing with no default value')
### Terms ###
terms <- paste(as.character(GENE), '[GENE] AND ', # provides search terms to be used with 'entrez_search' function of 'rentrez'
as.character(x), '[PORG]', # search for primary organism only
if(!missing(SLEN)) {paste(' AND ', as.character(SLEN), '[SLEN]', sep = '')}, # if a range of values is provided for 'SLEN = ', limit the sequence IDs returned by the given range of values
sep = '') # example term: 'atpB[GENE] AND Hydrocleys_martii[PORG] AND 500:5000[SLEN]'
### ID Search ###
print('Searching for IDs')
IDs <- unique(unlist(pblapply(terms, function(x){ # a function to find and create a vector of IDs from NCBI
tmp <- entrez_search(db = 'nucleotide', # searches the NCBI database for the term created above and returns a list of data found which includes, but is not limited to, the IDs of the found sequences
term = x,
retmax = RET)
if(length(tmp$ids) > (RET - 1)){ # provides a vector of IDs found based on the search of the NCBI database
IDs <- tmp$ids[[RET]]}
})))
if(length(IDs) == 0) stop('No IDs Found')
### NCBI Fetch ###
print('Fetching Sequence Data')
Seqs <- pblapply(IDs, function(x){ # a function to fetch sequence data from NCBI
tmp <- entrez_fetch(db = 'nuccore', id = x, rettype = 'gbc', retmode = 'xml') # fetches sequence data in an xml format from NCBI based on ID numbers obtained from the '### ID Search ###' function; data includes specimen accession number, taxonomy and sequence, as well as additional data
unlist(tmp, use.names = FALSE)
tmp <- xmlToList(tmp) # provides an R-friendly list of the xml data retrieved
rapply(tmp, function(x) gsub(' ', '_', x), how = 'replace') # replaces the spaces in x with '_' to prevent the sequence label being truncated when creating trees; replaces all spaces in the list, but we are only concerned with those found in 'x$INSDSeq$INSDSeq_organism' as that element contains the species combination (Genus_species)
})
### Write Fasta File ###
if(WRITE == TRUE) {
print('Writing Fasta File')
WriteFasta(Seqs, GENE = GENE, OUTSIDE = OUTSIDE, ...) # see 'WriteFasta' function below for details
}
### Save Vector of Included Taxa ###
if(REPLACEMENT == FALSE & OUTSIDE == FALSE) Seqs <<- sapply(Seqs, function(x){
sub('_[[:alpha:]]*\\..*$', '', x$INSDSeq$INSDSeq_organism)
}) # will save a vector, 'Seqs', of combination names to the global environment for comparison with sequence list edited following clustering and visual inspection
if(REPLACEMENT == FALSE & OUTSIDE == TRUE) Seqs <<- sapply(Seqs, function(x){
sub('_.*$', '', x$INSDSeq$INSDSeq_organism)
}) # will save a vector, 'Seqs', of genus names to the global environment for comparison with sequence list edited following clustering and visual inspection; to be used when adding taxa from outside of the research area
}
WriteFasta <- function(x, GENE = NULL, ACCESSION = FALSE, FAMILY = FALSE, COMBINATION = FALSE, GENUS = FALSE, COMP = FALSE, OUTSIDE = FALSE, APPEND = FALSE){ # function for taking sequence data and writing it as a fasta file
# x = list of sequence data downloaded from NCBI
# APPEND = whether to append the data to an existing file or not; 'APPEND = TRUE' when adding replacement and outside sequences
# see below in '### Function ###' for information on other arguments
### Error Codes ###
if(ACCESSION == FALSE & FAMILY == FALSE & COMBINATION == FALSE & GENUS == FALSE) stop('No labels provided for sequences; use ACCESSION, FAMILY, COMBINATION and/or GENUS arguments to provide labels for sequences')
if(missing(GENE)) stop('GENE argument missing with no default value')
### Function ###
fasta <- sapply(x, function(x){
paste('>',
if(ACCESSION == TRUE) paste(x$INSDSeq$INSDSeq_locus, '_', sep = ''), # adds an accession number to the sequence label
if(FAMILY == TRUE) paste(regmatches(x$INSDSeq$INSDSeq_taxonomy, regexpr('[[:alpha:]]*aceae', x$INSDSeq$INSDSeq_taxonomy)), '_', sep = ''), # adds 'Family' to the sequence label
if(COMBINATION == TRUE) sub('_[[:alpha:]]*\\..*$', '', x$INSDSeq$INSDSeq_organism), # adds 'Genus_species' to the sequence label
if(GENUS == TRUE) sub('_.*$', '', x$INSDSeq$INSDSeq_organism), # adds only 'Genus' to the sequence label
if(COMP == TRUE) '_comp.', # for composite; when adding taxa from outside of the research area, we only search NCBI at the genus level; different gene regions may give different species for the same genus, but we are not concerned with the species level for these taxa and 'comp.' allows us to create composite species when we combine the single family trees
if(OUTSIDE == TRUE) '_OUTSIDE', # an indicator that the taxa is from outside of the research area
'\n', x$INSDSeq$INSDSeq_sequence, # adds the sequence
sep = '')})
write(fasta, file.path('..', 'Results', 'sequences', as.character(GENE), paste(as.character(GENE), '_sequences.fasta', sep = '')), append = APPEND) # writes files to '../Results/sequences/GENE/GENE_sequences.fasta' or the Windows equivalent
}
del.taxa <- function(x, OUTSIDE = FALSE) { # a function for comparing vectors of taxa used to create trees to determine which taxa were removed through clustering and visual inspection
# x = the gene region of interest used to create the single gene tree; parameter should be written inside quotations
# OUTSIDE = whether or not we or comparing taxa outside of the research area
if(OUTSIDE == FALSE) {
tmp <- read.fasta(file.path('..', 'Results', 'sequences', as.character(x), paste(as.character(x), '_sequences.fasta', sep = '')))
tmp <- regmatches(tmp$seq.name, regexpr('[[:alpha:]]*_[^_]*$', tmp$seq.name))
setdiff(Seqs, tmp) # compares vectors 'Seqs' and 'tmp' and returns which elements are in 'Seqs' but not in 'tmp'; for our purposes, these vectors contain combination names and we are using 'setdiff()' to determine which sequences were deleted from the initial tree
}
if(OUTSIDE == TRUE) {
tmp <- read.fasta(file.path('..', 'Results', 'sequences', as.character(x), paste(as.character(x), '_sequences.fasta', sep = '')))
tmp <- sub('^.*aceae_', '', tmp$seq.name)
tmp <- sub('_.*$', '', tmp)
setdiff(Seqs, tmp) # same as above, but compares genus names rather than combination names
}
} # outputs contain the taxa removed, allowing for a replacement search
SeekAndFind(data$Combination, GENE = 'atpB', SLEN = '500:5000', RET = 1, WRITE = TRUE, ACCESSION = TRUE, FAMILY = TRUE, COMBINATION = TRUE) # a search of the NCBI database for taxa of interest with sequence data for the 'atpB' gene between 500 and 5000 nucleotides in length; writes the retrieved data to '../Results/sequences/atpB/atpB_sequences.fasta'; sequence labels are in the form of '>Accession_Family_Genus_species'; provides a vector ('Seqs') of combination names for taxa written to the fasta file
SeekAndFind(data$Combination, GENE = 'atpB', SLEN = '500:5000', RET = 1, WRITE = TRUE, ACCESSION = TRUE, FAMILY = TRUE, COMBINATION = TRUE) # a search of the NCBI database for taxa of interest with sequence data for the 'atpB' gene between 500 and 5000 nucleotides in length; writes the retrieved data to '../Results/sequences/atpB/atpB_sequences.fasta'; sequence labels are in the form of '>Accession_Family_Genus_species'; provides a vector ('Seqs') of combination names for taxa written to the fasta file
data <- read.csv('./RBGE.csv', header = TRUE) # database containing the species of interest
data <- read.csv('./RBGE.csv', header = TRUE) # database containing the species of interest
data <- data[1:4] # the database contains more information than we need for building a phylogeny; for the sake of clarity, we are only taking the first four columns which contain the family, genus, species and combination (Genus species)
data <- data[1:4] # the database contains more information than we need for building a phylogeny; for the sake of clarity, we are only taking the first four columns which contain the family, genus, species and combination (Genus species)
data$Combination <- gsub(' ', '_', data$Combination) # for ease of comparison purposes, the ' ' in the combination is replaced with an '_'
library(rentrez)
library(pbapply)
library(XML)
library(plyr)
library(phylotools)
SeekAndFind <- function(x, GENE = NULL, SLEN = NULL, RET = 1, REPLACEMENT = FALSE, OUTSIDE = FALSE, WRITE = FALSE, ...){ # a function for searching the NCBI database for sequences IDs and downloading sequence data based on the IDs found
# x = vector containing taxa names
# GENE = the gene region of interest; parameter should be written inside quotations
# SLEN = length of desired sequences to be returned; parameter should be written inside quotations
# RET = the sequence ID to be returned from the NCBI database; defaults to the first sequence ID per species per desired gene; increase if replacing anomalous sequences
# REPLACEMENT = whether the search is being used to search for replacement sequences for deleted taxa or not
# OUTSIDE = whether the search is being used to look for species outside of the primary research area
# WRITE = whether to write the sequences to a fasta file or not; see 'WriteFasta' function for details and arguments
# ... = arguments to be passed on to the 'WriteFasta' function
### Error Codes ###
if(missing(GENE)) stop('GENE argument missing with no default value')
### Terms ###
terms <- paste(as.character(GENE), '[GENE] AND ', # provides search terms to be used with 'entrez_search' function of 'rentrez'
as.character(x), '[PORG]', # search for primary organism only
if(!missing(SLEN)) {paste(' AND ', as.character(SLEN), '[SLEN]', sep = '')}, # if a range of values is provided for 'SLEN = ', limit the sequence IDs returned by the given range of values
sep = '') # example term: 'atpB[GENE] AND Hydrocleys_martii[PORG] AND 500:5000[SLEN]'
### ID Search ###
print('Searching for IDs')
IDs <- unique(unlist(pblapply(terms, function(x){ # a function to find and create a vector of IDs from NCBI
tmp <- entrez_search(db = 'nucleotide', # searches the NCBI database for the term created above and returns a list of data found which includes, but is not limited to, the IDs of the found sequences
term = x,
retmax = RET)
if(length(tmp$ids) > (RET - 1)){ # provides a vector of IDs found based on the search of the NCBI database
IDs <- tmp$ids[[RET]]}
})))
if(length(IDs) == 0) stop('No IDs Found')
### NCBI Fetch ###
print('Fetching Sequence Data')
Seqs <- pblapply(IDs, function(x){ # a function to fetch sequence data from NCBI
tmp <- entrez_fetch(db = 'nuccore', id = x, rettype = 'gbc', retmode = 'xml') # fetches sequence data in an xml format from NCBI based on ID numbers obtained from the '### ID Search ###' function; data includes specimen accession number, taxonomy and sequence, as well as additional data
unlist(tmp, use.names = FALSE)
tmp <- xmlToList(tmp) # provides an R-friendly list of the xml data retrieved
rapply(tmp, function(x) gsub(' ', '_', x), how = 'replace') # replaces the spaces in x with '_' to prevent the sequence label being truncated when creating trees; replaces all spaces in the list, but we are only concerned with those found in 'x$INSDSeq$INSDSeq_organism' as that element contains the species combination (Genus_species)
})
### Write Fasta File ###
if(WRITE == TRUE) {
print('Writing Fasta File')
WriteFasta(Seqs, GENE = GENE, OUTSIDE = OUTSIDE, ...) # see 'WriteFasta' function below for details
}
### Save Vector of Included Taxa ###
if(REPLACEMENT == FALSE & OUTSIDE == FALSE) Seqs <<- sapply(Seqs, function(x){
sub('_[[:alpha:]]*\\..*$', '', x$INSDSeq$INSDSeq_organism)
}) # will save a vector, 'Seqs', of combination names to the global environment for comparison with sequence list edited following clustering and visual inspection
if(REPLACEMENT == FALSE & OUTSIDE == TRUE) Seqs <<- sapply(Seqs, function(x){
sub('_.*$', '', x$INSDSeq$INSDSeq_organism)
}) # will save a vector, 'Seqs', of genus names to the global environment for comparison with sequence list edited following clustering and visual inspection; to be used when adding taxa from outside of the research area
}
WriteFasta <- function(x, GENE = NULL, ACCESSION = FALSE, FAMILY = FALSE, COMBINATION = FALSE, GENUS = FALSE, COMP = FALSE, OUTSIDE = FALSE, APPEND = FALSE){ # function for taking sequence data and writing it as a fasta file
# x = list of sequence data downloaded from NCBI
# APPEND = whether to append the data to an existing file or not; 'APPEND = TRUE' when adding replacement and outside sequences
# see below in '### Function ###' for information on other arguments
### Error Codes ###
if(ACCESSION == FALSE & FAMILY == FALSE & COMBINATION == FALSE & GENUS == FALSE) stop('No labels provided for sequences; use ACCESSION, FAMILY, COMBINATION and/or GENUS arguments to provide labels for sequences')
if(missing(GENE)) stop('GENE argument missing with no default value')
### Function ###
fasta <- sapply(x, function(x){
paste('>',
if(ACCESSION == TRUE) paste(x$INSDSeq$INSDSeq_locus, '_', sep = ''), # adds an accession number to the sequence label
if(FAMILY == TRUE) paste(regmatches(x$INSDSeq$INSDSeq_taxonomy, regexpr('[[:alpha:]]*aceae', x$INSDSeq$INSDSeq_taxonomy)), '_', sep = ''), # adds 'Family' to the sequence label
if(COMBINATION == TRUE) sub('_[[:alpha:]]*\\..*$', '', x$INSDSeq$INSDSeq_organism), # adds 'Genus_species' to the sequence label
if(GENUS == TRUE) sub('_.*$', '', x$INSDSeq$INSDSeq_organism), # adds only 'Genus' to the sequence label
if(COMP == TRUE) '_comp.', # for composite; when adding taxa from outside of the research area, we only search NCBI at the genus level; different gene regions may give different species for the same genus, but we are not concerned with the species level for these taxa and 'comp.' allows us to create composite species when we combine the single family trees
if(OUTSIDE == TRUE) '_OUTSIDE', # an indicator that the taxa is from outside of the research area
'\n', x$INSDSeq$INSDSeq_sequence, # adds the sequence
sep = '')})
write(fasta, file.path('..', 'Results', 'sequences', as.character(GENE), paste(as.character(GENE), '_sequences.fasta', sep = '')), append = APPEND) # writes files to '../Results/sequences/GENE/GENE_sequences.fasta' or the Windows equivalent
}
del.taxa <- function(x, OUTSIDE = FALSE) { # a function for comparing vectors of taxa used to create trees to determine which taxa were removed through clustering and visual inspection
# x = the gene region of interest used to create the single gene tree; parameter should be written inside quotations
# OUTSIDE = whether or not we or comparing taxa outside of the research area
if(OUTSIDE == FALSE) {
tmp <- read.fasta(file.path('..', 'Results', 'sequences', as.character(x), paste(as.character(x), '_sequences.fasta', sep = '')))
tmp <- regmatches(tmp$seq.name, regexpr('[[:alpha:]]*_[^_]*$', tmp$seq.name))
setdiff(Seqs, tmp) # compares vectors 'Seqs' and 'tmp' and returns which elements are in 'Seqs' but not in 'tmp'; for our purposes, these vectors contain combination names and we are using 'setdiff()' to determine which sequences were deleted from the initial tree
}
if(OUTSIDE == TRUE) {
tmp <- read.fasta(file.path('..', 'Results', 'sequences', as.character(x), paste(as.character(x), '_sequences.fasta', sep = '')))
tmp <- sub('^.*aceae_', '', tmp$seq.name)
tmp <- sub('_.*$', '', tmp)
setdiff(Seqs, tmp) # same as above, but compares genus names rather than combination names
}
} # outputs contain the taxa removed, allowing for a replacement search
SeekAndFind(data$Combination, GENE = 'rbcL', SLEN = '500:5000', RET = 1, WRITE = TRUE, ACCESSION = TRUE, FAMILY = TRUE, COMBINATION = TRUE) # a search of the NCBI database for taxa of interest with sequence data for the 'atpB' gene between 500 and 5000 nucleotides in length; writes the retrieved data to '../Results/sequences/atpB/atpB_sequences.fasta'; sequence labels are in the form of '>Accession_Family_Genus_species'; provides a vector ('Seqs') of combination names for taxa written to the fasta file
SeekAndFind(del.taxa('rbcL'), GENE = 'rbcL', SLEN = '500:5000', RET = 2, REPLACEMENT = TRUE, WRITE = TRUE, ACCESSION = TRUE, FAMILY = TRUE, COMBINATION = TRUE, APPEND = TRUE) # here we increase 'RET' to 2, grabbing the second ID for the desired species if available, ensuring that it was not an ID from the initial search; if running more than one replacement search, simply increase RET accordingly. also made 'APPEND = TRUE' to add found sequences to the sequence file instead of overwriting the file and 'REPLACEMENT = TRUE' to avoid overwriting 'Seqs' in case further comparison is required; note that the vector containing taxa to be replaced comes from the 'del.taxa' function
SeekAndFind <- function(x, GENE = NULL, SLEN = NULL, RET = 1, REPLACEMENT = FALSE, OUTSIDE = FALSE, WRITE = FALSE, ...){ # a function for searching the NCBI database for sequences IDs and downloading sequence data based on the IDs found
# x = vector containing taxa names
# GENE = the gene region of interest; parameter should be written inside quotations
# SLEN = length of desired sequences to be returned; parameter should be written inside quotations
# RET = the sequence ID to be returned from the NCBI database; defaults to the first sequence ID per species per desired gene; increase if replacing anomalous sequences
# REPLACEMENT = whether the search is being used to search for replacement sequences for deleted taxa or not
# OUTSIDE = whether the search is being used to look for species outside of the primary research area
# WRITE = whether to write the sequences to a fasta file or not; see 'WriteFasta' function for details and arguments
# ... = arguments to be passed on to the 'WriteFasta' function
### Error Codes ###
if(missing(GENE)) stop('GENE argument missing with no default value')
### Terms ###
terms <<- paste(as.character(GENE), '[GENE] AND ', # provides search terms to be used with 'entrez_search' function of 'rentrez'
as.character(x), '[PORG]', # search for primary organism only
if(!missing(SLEN)) {paste(' AND ', as.character(SLEN), '[SLEN]', sep = '')}, # if a range of values is provided for 'SLEN = ', limit the sequence IDs returned by the given range of values
sep = '') # example term: 'atpB[GENE] AND Hydrocleys_martii[PORG] AND 500:5000[SLEN]'
### ID Search ###
print('Searching for IDs')
IDs <- unique(unlist(pblapply(terms, function(x){ # a function to find and create a vector of IDs from NCBI
tmp <- entrez_search(db = 'nucleotide', # searches the NCBI database for the term created above and returns a list of data found which includes, but is not limited to, the IDs of the found sequences
term = x,
retmax = RET)
if(length(tmp$ids) > (RET - 1)){ # provides a vector of IDs found based on the search of the NCBI database
IDs <- tmp$ids[[RET]]}
})))
if(length(IDs) == 0) stop('No IDs Found')
### NCBI Fetch ###
print('Fetching Sequence Data')
Seqs <- pblapply(IDs, function(x){ # a function to fetch sequence data from NCBI
tmp <- entrez_fetch(db = 'nuccore', id = x, rettype = 'gbc', retmode = 'xml') # fetches sequence data in an xml format from NCBI based on ID numbers obtained from the '### ID Search ###' function; data includes specimen accession number, taxonomy and sequence, as well as additional data
unlist(tmp, use.names = FALSE)
tmp <- xmlToList(tmp) # provides an R-friendly list of the xml data retrieved
rapply(tmp, function(x) gsub(' ', '_', x), how = 'replace') # replaces the spaces in x with '_' to prevent the sequence label being truncated when creating trees; replaces all spaces in the list, but we are only concerned with those found in 'x$INSDSeq$INSDSeq_organism' as that element contains the species combination (Genus_species)
})
### Write Fasta File ###
if(WRITE == TRUE) {
print('Writing Fasta File')
WriteFasta(Seqs, GENE = GENE, OUTSIDE = OUTSIDE, ...) # see 'WriteFasta' function below for details
}
### Save Vector of Included Taxa ###
if(REPLACEMENT == FALSE & OUTSIDE == FALSE) Seqs <<- sapply(Seqs, function(x){
sub('_[[:alpha:]]*\\..*$', '', x$INSDSeq$INSDSeq_organism)
}) # will save a vector, 'Seqs', of combination names to the global environment for comparison with sequence list edited following clustering and visual inspection
if(REPLACEMENT == FALSE & OUTSIDE == TRUE) Seqs <<- sapply(Seqs, function(x){
sub('_.*$', '', x$INSDSeq$INSDSeq_organism)
}) # will save a vector, 'Seqs', of genus names to the global environment for comparison with sequence list edited following clustering and visual inspection; to be used when adding taxa from outside of the research area
}
SeekAndFind(del.taxa('rbcL'), GENE = 'rbcL', SLEN = '500:5000', RET = 2, REPLACEMENT = TRUE, WRITE = TRUE, ACCESSION = TRUE, FAMILY = TRUE, COMBINATION = TRUE, APPEND = TRUE) # here we increase 'RET' to 2, grabbing the second ID for the desired species if available, ensuring that it was not an ID from the initial search; if running more than one replacement search, simply increase RET accordingly. also made 'APPEND = TRUE' to add found sequences to the sequence file instead of overwriting the file and 'REPLACEMENT = TRUE' to avoid overwriting 'Seqs' in case further comparison is required; note that the vector containing taxa to be replaced comes from the 'del.taxa' function
SeekAndFind <- function(x, GENE = NULL, SLEN = NULL, RET = 1, REPLACEMENT = FALSE, OUTSIDE = FALSE, WRITE = FALSE, ...){ # a function for searching the NCBI database for sequences IDs and downloading sequence data based on the IDs found
# x = vector containing taxa names
# GENE = the gene region of interest; parameter should be written inside quotations
# SLEN = length of desired sequences to be returned; parameter should be written inside quotations
# RET = the sequence ID to be returned from the NCBI database; defaults to the first sequence ID per species per desired gene; increase if replacing anomalous sequences
# REPLACEMENT = whether the search is being used to search for replacement sequences for deleted taxa or not
# OUTSIDE = whether the search is being used to look for species outside of the primary research area
# WRITE = whether to write the sequences to a fasta file or not; see 'WriteFasta' function for details and arguments
# ... = arguments to be passed on to the 'WriteFasta' function
### Error Codes ###
if(missing(GENE)) stop('GENE argument missing with no default value')
### Terms ###
terms <- paste(as.character(GENE), '[GENE] AND ', # provides search terms to be used with 'entrez_search' function of 'rentrez'
as.character(x), '[PORG]', # search for primary organism only
if(!missing(SLEN)) {paste(' AND ', as.character(SLEN), '[SLEN]', sep = '')}, # if a range of values is provided for 'SLEN = ', limit the sequence IDs returned by the given range of values
sep = '') # example term: 'atpB[GENE] AND Hydrocleys_martii[PORG] AND 500:5000[SLEN]'
### ID Search ###
print('Searching for IDs')
IDs <- unique(unlist(pblapply(terms, function(x){ # a function to find and create a vector of IDs from NCBI
tmp <- entrez_search(db = 'nucleotide', # searches the NCBI database for the term created above and returns a list of data found which includes, but is not limited to, the IDs of the found sequences
term = x,
retmax = RET)
if(length(tmp$ids) > (RET - 1)){ # provides a vector of IDs found based on the search of the NCBI database
IDs <- tmp$ids[[RET]]}
})))
if(length(IDs) == 0) stop('No IDs Found')
### NCBI Fetch ###
print('Fetching Sequence Data')
Seqs <- pblapply(IDs, function(x){ # a function to fetch sequence data from NCBI
tmp <- entrez_fetch(db = 'nuccore', id = x, rettype = 'gbc', retmode = 'xml') # fetches sequence data in an xml format from NCBI based on ID numbers obtained from the '### ID Search ###' function; data includes specimen accession number, taxonomy and sequence, as well as additional data
unlist(tmp, use.names = FALSE)
tmp <- xmlToList(tmp) # provides an R-friendly list of the xml data retrieved
rapply(tmp, function(x) gsub(' ', '_', x), how = 'replace') # replaces the spaces in x with '_' to prevent the sequence label being truncated when creating trees; replaces all spaces in the list, but we are only concerned with those found in 'x$INSDSeq$INSDSeq_organism' as that element contains the species combination (Genus_species)
})
### Write Fasta File ###
if(WRITE == TRUE) {
print('Writing Fasta File')
WriteFasta(Seqs, GENE = GENE, OUTSIDE = OUTSIDE, ...) # see 'WriteFasta' function below for details
}
### Save Vector of Included Taxa ###
if(REPLACEMENT == FALSE & OUTSIDE == FALSE) Seqs <<- sapply(Seqs, function(x){
sub('_[[:alpha:]]*\\..*$', '', x$INSDSeq$INSDSeq_organism)
}) # will save a vector, 'Seqs', of combination names to the global environment for comparison with sequence list edited following clustering and visual inspection
if(REPLACEMENT == FALSE & OUTSIDE == TRUE) Seqs <<- sapply(Seqs, function(x){
sub('_.*$', '', x$INSDSeq$INSDSeq_organism)
}) # will save a vector, 'Seqs', of genus names to the global environment for comparison with sequence list edited following clustering and visual inspection; to be used when adding taxa from outside of the research area
}
SeekAndFind(del.taxa('rbcL'), GENE = 'rbcL', SLEN = '500:5000', RET = 2, REPLACEMENT = TRUE, WRITE = TRUE, ACCESSION = TRUE, FAMILY = TRUE, COMBINATION = TRUE, APPEND = TRUE) # here we increase 'RET' to 2, grabbing the second ID for the desired species if available, ensuring that it was not an ID from the initial search; if running more than one replacement search, simply increase RET accordingly. also made 'APPEND = TRUE' to add found sequences to the sequence file instead of overwriting the file and 'REPLACEMENT = TRUE' to avoid overwriting 'Seqs' in case further comparison is required; note that the vector containing taxa to be replaced comes from the 'del.taxa' function
del.taxa <- function(x, OUTSIDE = FALSE) { # a function for comparing vectors of taxa used to create trees to determine which taxa were removed through clustering and visual inspection
# x = the gene region of interest used to create the single gene tree; parameter should be written inside quotations
# OUTSIDE = whether or not we or comparing taxa outside of the research area
if(OUTSIDE == FALSE) {
tmp <- read.fasta(file.path('..', 'Results', 'sequences', as.character(x), paste(as.character(x), '_sequences.fasta', sep = '')))
tmp <- regmatches(tmp$seq.name, regexpr('[[:alpha:]]*_[^_]*$', tmp$seq.name))
setdiff(Seqs, tmp) # compares vectors 'Seqs' and 'tmp' and returns which elements are in 'Seqs' but not in 'tmp'; for our purposes, these vectors contain combination names and we are using 'setdiff()' to determine which sequences were deleted from the initial tree
}
} # outputs contain the taxa removed, allowing for a replacement search
SeekAndFind(del.taxa('rbcL'), GENE = 'rbcL', SLEN = '500:5000', RET = 2, REPLACEMENT = TRUE, WRITE = TRUE, ACCESSION = TRUE, FAMILY = TRUE, COMBINATION = TRUE, APPEND = TRUE) # here we increase 'RET' to 2, grabbing the second ID for the desired species if available, ensuring that it was not an ID from the initial search; if running more than one replacement search, simply increase RET accordingly. also made 'APPEND = TRUE' to add found sequences to the sequence file instead of overwriting the file and 'REPLACEMENT = TRUE' to avoid overwriting 'Seqs' in case further comparison is required; note that the vector containing taxa to be replaced comes from the 'del.taxa' function
del.taxa <- function(x, OUTSIDE = FALSE){ # a function for comparing vectors of taxa used to create trees to determine which taxa were removed through clustering and visual inspection
# x = the gene region of interest used to create the single gene tree; parameter should be written inside quotations
# OUTSIDE = whether or not we or comparing taxa outside of the research area
if(OUTSIDE == FALSE) {
tmp <- read.fasta(file.path('..', 'Results', 'sequences', as.character(x), paste(as.character(x), '_sequences.fasta', sep = '')))
tmp <- regmatches(tmp$seq.name, regexpr('[[:alpha:]]*_[^_]*$', tmp$seq.name))
setdiff(Seqs, tmp) # compares vectors 'Seqs' and 'tmp' and returns which elements are in 'Seqs' but not in 'tmp'; for our purposes, these vectors contain combination names and we are using 'setdiff()' to determine which sequences were deleted from the initial tree
} else {
tmp <- read.fasta(file.path('..', 'Results', 'sequences', as.character(x), paste(as.character(x), '_sequences.fasta', sep = '')))
tmp <- sub('^.*aceae_', '', tmp$seq.name)
tmp <- sub('_.*$', '', tmp)
setdiff(Seqs, tmp) # same as above, but compares genus names rather than combination names
}
} # outputs contain the taxa removed, allowing for a replacement search
SeekAndFind(del.taxa('rbcL'), GENE = 'rbcL', SLEN = '500:5000', RET = 2, REPLACEMENT = TRUE, WRITE = TRUE, ACCESSION = TRUE, FAMILY = TRUE, COMBINATION = TRUE, APPEND = TRUE) # here we increase 'RET' to 2, grabbing the second ID for the desired species if available, ensuring that it was not an ID from the initial search; if running more than one replacement search, simply increase RET accordingly. also made 'APPEND = TRUE' to add found sequences to the sequence file instead of overwriting the file and 'REPLACEMENT = TRUE' to avoid overwriting 'Seqs' in case further comparison is required; note that the vector containing taxa to be replaced comes from the 'del.taxa' function
?seq_along
woke <- function(name) {
if (name = 'SuperHans') stop('Not Woke')
woke <- function(name) {
if (name == 'SuperHans') stop('Not Woke')
print('woke')
}
woke
woke('Codemonkey')
woke('SuperHans')
rm(woke)
library(ape)
library(ggtree)
tree <- read.tree(text = "((Dry, Dry), (Dry/Humid, (Humid, Humid)));")
ggTree <- ggtree(tree) +
geom_tiplab(hjust = -0.1) +
ggplot2::xlim(c(0, 0.75)) + # provide xlims to prevent labels from running off page
theme(text = element_text(family = "Helvetica",
colour = "#404040",
size = 12))
library(tidyverse)
ggTree <- ggtree(tree) +
geom_tiplab(hjust = -0.1) +
ggplot2::xlim(c(0, 0.75)) + # provide xlims to prevent labels from running off page
theme(text = element_text(family = "Helvetica",
colour = "#404040",
size = 12))
ggTree %>% rotate(6)
ggTree <- ggtree(tree) +
geom_tiplab(hjust = -0.1) +
ggplot2::xlim(c(0, 1)) + # provide xlims to prevent labels from running off page
theme(text = element_text(family = "Helvetica",
colour = "#404040",
size = 12))
ggTree %>% rotate(6)
ggTree <- ggtree(tree) +
geom_tiplab(hjust = -0.1) +
ggplot2::xlim(c(0, 3)) + # provide xlims to prevent labels from running off page
theme(text = element_text(family = "Helvetica",
colour = "#404040",
size = 12))
ggTree %>% rotate(6)
ggTree <- ggtree(tree) +
geom_tiplab(hjust = -0.1) +
ggplot2::xlim(c(0, 5)) + # provide xlims to prevent labels from running off page
theme(text = element_text(family = "Helvetica",
colour = "#404040",
size = 12))
ggTree %>% rotate(6)
ggTree <- ggtree(tree) +
geom_tiplab(hjust = -0.1) +
ggplot2::xlim(c(0, 4)) + # provide xlims to prevent labels from running off page
theme(text = element_text(family = "Helvetica",
colour = "#404040",
size = 12))
ggTree %>% rotate(6)
ggTree <- ggtree(tree) +
geom_tiplab(hjust = -0.1) +
ggplot2::xlim(c(0, 3.5)) + # provide xlims to prevent labels from running off page
theme(text = element_text(family = "Helvetica",
colour = "#404040",
size = 12))
ggTree %>% rotate(6)
?plot_grid
??plot_grid
library(tidyverse)
climPCA$var$contrib
# add brahms number and species columns; rename bioClim columns
(bioClim <- bioClim %>%
add_column(brahms = sol$brahms,
species = sol$species,
clade = sol$clade, .before = 1) %>%
rename_at(vars(V1:V19), ~ varNames) %>%
na.omit())
